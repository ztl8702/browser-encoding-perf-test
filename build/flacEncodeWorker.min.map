{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/flac/flacEncodeWorker.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","default","object","property","prototype","hasOwnProperty","p","s","e","length","configurable","writable","importScripts","FLAC_ERRORS","0","1","2","3","4","5","6","7","8","EncoderState","freeze","UNINTIALISED","WORKING","FINISHED","Encoder","sampleRate","bitDepth","arguments","bufferSize","TypeError","this","_encoderId","_flacBuffers","_flacLength","_state","_data","_onMetadataAvailable","Flac","isReady","Error","_sampleRate","_bitDepth","_bufferSize","init_libflac_encoder","init_encoder_stream","_onEncodedData","audioData","bufferLength","bufferI32","Int32Array","view","DataView","buffer","index","setInt32","FLAC__stream_encoder_process_interleaved","errorNo","FLAC__stream_encoder_get_state","console","error","status","FLAC__stream_encoder_finish","log","FLAC__stream_encoder_delete","_exportFlacBlob","samplesEncoded","samples","arrays","totalLength","result","Uint8Array","offset","len","set","Blob","type","bytes","push","byteLength","encoder","self","onmessage","data","command","bps","config","onready","setTimeout","encode","buf","finish","getBlob","postMessage"],"mappings":"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","file":"flacEncodeWorker.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/libs/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/**\n * WebWorker that does FLAC encoding using libflac.js\n *\n * This file does not go through webpack.\n */\n\nimportScripts('/build/libflac3-1.3.2.min.js');\n\n\nconst FLAC_ERRORS = {\n    0: 'FLAC__STREAM_ENCODER_OK', // The encoder is in the normal OK state and\n    // samples can be processed.\n    1: 'FLAC__STREAM_ENCODER_UNINITIALIZED', // The encoder is in the\n    // uninitialized state one of the FLAC__stream_encoder_init_*() functions\n    // must be called before samples can be processed.\n    2: 'FLAC__STREAM_ENCODER_OGG_ERROR', // An error occurred in the underlying\n    // Ogg layer.\n    3: 'FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR', // An error occurred in the\n    // underlying verify stream decoder; check\n    // FLAC__stream_encoder_get_verify_decoder_state().\n    4: 'FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA', // The verify\n    // decoder detected a mismatch between the original audio signal and\n    // the decoded audio signal.\n    5: 'FLAC__STREAM_ENCODER_CLIENT_ERROR', // One of the callbacks returned\n    // a fatal error.\n    6: 'FLAC__STREAM_ENCODER_IO_ERROR', // An I/O error occurred while\n    // opening/reading/writing a file. Check errno.\n    7: 'FLAC__STREAM_ENCODER_FRAMING_ERROR', // An error occurred while writing\n    // the stream; usually, the write_callback returned an error.\n    8: 'FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR' // Memory allocation\n    // failed.\n};\n\nconst EncoderState = Object.freeze({\n    UNINTIALISED: Symbol('uninitialised'),\n    WORKING: Symbol('working'),\n    FINISHED: Symbol('finished')\n});\n\n/**\n * Concat multiple Uint8Arrays into one.\n *\n * @param {Array} arrays - Array of Uint8 arrays.\n * @param {*} totalLength - Total length of all Uint8Arrays.\n * @returns {Uint8Array}\n */\nfunction mergeUint8Arrays(arrays, totalLength) {\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    const len = arrays.length;\n\n    for (let i = 0; i < len; i++) {\n        const buffer = arrays[i];\n\n        result.set(buffer, offset);\n        offset += buffer.length;\n    }\n\n    return result;\n}\n\n/**\n * Wrapper class around libflac API.\n */\nclass Encoder {\n\n    /**\n     * Flac encoder instance ID. (As per libflac.js API)\n     * @private\n     */\n    _encoderId = 0;\n\n    /**\n     * Sample rate\n     * @private\n     */\n    _sampleRate;\n\n    /**\n     * Bit depth (bits per sample)\n     * @private\n     */\n    _bitDepth;\n\n    /**\n     * Buffer size\n     * @private\n     */\n    _bufferSize;\n\n    _flacBuffers = [];\n\n    _flacLength = 0;\n\n    _state = EncoderState.UNINTIALISED;\n\n    _data = null;\n\n\n    /**\n     * Constructor.\n     * Note: only create instance when Flac.isReady() returns true.\n     *\n     * @param {number} sampleRate - Sample rate of the raw audio data.\n     * @param {number} bitDepth - Bit depth (bit per sample).\n     * @param {number} bufferSize - The size of each batch.\n     */\n    constructor(sampleRate, bitDepth = 16, bufferSize = 4096) {\n        if (!Flac.isReady()) {\n            throw new Error('libflac is not ready yet!');\n        }\n\n        this._sampleRate = sampleRate;\n        this._bitDepth = bitDepth;\n        this._bufferSize = bufferSize;\n\n        // create the encoder\n        this._encoderId = Flac.init_libflac_encoder(\n            this._sampleRate,\n            1, // Mono channel\n            this._bitDepth,\n            5, // Compression level TODO: change this later\n            0, // Unknown total samples,\n            true, // Checksum TODO: i don't know what this is\n            0 // Auto determine block size (samples per frame)\n        );\n\n        if (this._encoderId === 0) {\n            throw new Error('Failed to create libflac encoder.');\n        }\n\n        // initialise the encoder\n        const initResult = Flac.init_encoder_stream(\n            this._encoderId,\n            this._onEncodedData.bind(this),\n            this._onMetadataAvailable.bind(this)\n        );\n\n        if (initResult !== 0) {\n            throw new Error('Failed to initalise libflac encoder.');\n        }\n\n        this._state = EncoderState.WORKING;\n    }\n\n    /**\n     * Receive and encode new data.\n     *\n     * @param {*} audioData - Raw audio data.\n     * @returns {void}\n     */\n    encode(audioData) {\n        if (this._state !== EncoderState.WORKING) {\n            throw new Error('Encoder is not ready or has finished.');\n        }\n\n        if (!Flac.isReady()) {\n            throw new Error('Flac not ready');\n        }\n        const bufferLength = audioData.length;\n\n        // convert to Uint32,\n        // appearantly libflac requires 32-bit signed integer input\n        // but why unsigned 32bit array?\n        const bufferI32 = new Int32Array(bufferLength);\n        const view = new DataView(bufferI32.buffer);\n        const volume = 1;\n        let index = 0;\n\n        for (let i = 0; i < bufferLength; i++) {\n            view.setInt32(index, audioData[i] * (0x7FFF * volume), true);\n            index += 4; // 4 bytes (32bit)\n        }\n\n        // pass it to libflac\n        const status = Flac.FLAC__stream_encoder_process_interleaved(\n            this._encoderId,\n            bufferI32,\n            bufferI32.length\n        );\n\n        if (status !== true) {\n            // get error\n\n            const errorNo\n                = Flac.FLAC__stream_encoder_get_state(this._encoderId);\n\n            console.error('Error during encoding', FLAC_ERRORS[errorNo]);\n        }\n    }\n\n    /**\n     * Signals the termination of encoding.\n     *\n     * @returns {void}\n     */\n    finish() {\n        if (this._state === EncoderState.WORKING) {\n            this._state = EncoderState.FINISHED;\n\n            const status = Flac.FLAC__stream_encoder_finish(this._encoderId);\n\n            console.log('flac finish: ', status);\n\n            // free up resources\n            Flac.FLAC__stream_encoder_delete(this._encoderId);\n\n            this._data = this._exportFlacBlob();\n        }\n    }\n\n    /**\n     * Gets the stats.\n     *\n     * @returns {Object}\n     */\n    getStats() {\n        return {\n            'samplesEncoded': this._bufferSize\n        };\n    }\n\n    /**\n     * Gets the encoded flac file.\n     *\n     * @returns {Blob} - The encoded flac file.\n     */\n    getBlob() {\n        if (this._state === EncoderState.FINISHED) {\n            return this._data;\n        }\n\n        return null;\n    }\n\n    /**\n     * Converts flac buffer to a Blob.\n     *\n     * @private\n     * @returns {void}\n     */\n    _exportFlacBlob() {\n        const samples = mergeUint8Arrays(this._flacBuffers, this._flacLength);\n\n        const blob = new Blob([ samples ], { type: 'audio/flac' });\n\n        return blob;\n    }\n\n    /**\n     * Callback function for saving encoded Flac data.\n     * This is invoked by libflac.\n     *\n     *\n     * @private\n     * @param {*} buffer - The encoded Flac data.\n     * @param {*} bytes - Number of bytes in the data.\n     * @returns {void}\n     */\n    _onEncodedData(buffer, bytes) {\n        this._flacBuffers.push(buffer);\n        this._flacLength += buffer.byteLength;\n    }\n\n    /**\n     * Callback function for receiving metadata.\n     *\n     * @private\n     * @returns {void}\n     */\n    _onMetadataAvailable = () => {\n        // do nothing\n    }\n}\n\n\nlet encoder = null;\n\nself.onmessage = function(e) {\n\n    switch (e.data.command) {\n    case 'init':\n    {\n        const bps = e.data.config.bps;\n        const sampleRate = e.data.config.sampleRate;\n\n        if (Flac.isReady()) {\n            encoder = new Encoder(sampleRate, bps);\n        } else {\n            Flac.onready = function() {\n                setTimeout(() => {\n                    encoder = new Encoder(sampleRate, bps);\n                }, 0);\n            };\n        }\n        break;\n    }\n\n    case 'encode':\n        if (encoder === null) {\n            console\n                .error('flacEncoderWorker:'\n                + 'received data when the encoder is not ready.');\n        } else {\n            encoder.encode(e.data.buf);\n        }\n        break;\n\n    case 'finish':\n        if (encoder !== null) {\n            encoder.finish();\n            const data = encoder.getBlob();\n\n            self.postMessage(\n                {\n                    command: 'end',\n                    buf: data\n                }\n            );\n            encoder = null;\n        }\n        break;\n    }\n};\n\n/**\n * if(wavBuffers.length > 0){\n        //if there is buffered audio: encode buffered first (and clear buffer)\n        var len = wavBuffers.length;\n        var buffered = wavBuffers.splice(0, len);\n        for(var i=0; i < len; ++i){\n            doEncodeFlac(buffered[i]);\n        }\n    }\n */\n"],"sourceRoot":""}